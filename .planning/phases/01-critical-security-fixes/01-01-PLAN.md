---
phase: 01-critical-security-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260131000001_audit_rls_policies.sql
  - supabase/migrations/20260131000002_audit_security_definer.sql
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All RLS policies query database tables (teachers/students) instead of user_metadata"
    - "All SECURITY DEFINER functions verify auth.uid() matches target before execution"
    - "No authorization decision relies on JWT user_metadata field"
  artifacts:
    - path: "supabase/migrations/20260131000001_audit_rls_policies.sql"
      provides: "RLS policy fixes for any tables still using user_metadata"
      contains: "DROP POLICY|CREATE POLICY"
    - path: "supabase/migrations/20260131000002_audit_security_definer.sql"
      provides: "SECURITY DEFINER function fixes with auth.uid() checks"
      contains: "auth.uid()"
  key_links:
    - from: "RLS policies"
      to: "public.is_admin() function"
      via: "function call in policy USING clause"
      pattern: "public\\.is_admin\\(\\)"
    - from: "SECURITY DEFINER functions"
      to: "auth.uid()"
      via: "authorization check at function start"
      pattern: "IF auth\\.uid\\(\\)"
---

<objective>
Audit and fix all database-level authorization to ensure RLS policies and SECURITY DEFINER functions use database state (not user_metadata) and verify auth.uid() before execution.

Purpose: Eliminates authorization bypass vulnerabilities where users could modify their JWT user_metadata to gain unauthorized access. This is the foundation for all other security layers.

Output: Two migration files that systematically fix any remaining authorization vulnerabilities at the database level.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-security-fixes/01-CONTEXT.md
@.planning/phases/01-critical-security-fixes/01-RESEARCH.md

# Key reference files (established patterns)
@supabase/migrations/20260126000001_fix_award_xp_security.sql
@supabase/migrations/20260127000001_fix_admin_rls_verification.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and fix RLS policies (SEC-01)</name>
  <files>supabase/migrations/20260131000001_audit_rls_policies.sql</files>
  <action>
Audit ALL RLS policies across all tables for user_metadata usage. Create a migration that fixes any policies still relying on user_metadata.

1. Query current RLS policies using Supabase SQL:
```sql
SELECT schemaname, tablename, policyname, qual, with_check
FROM pg_policies
WHERE schemaname = 'public';
```

2. For EACH policy found, check if it uses:
   - `auth.jwt() -> 'user_metadata'` (VULNERABLE - must fix)
   - `auth.jwt() ->> 'role'` (VULNERABLE - must fix)
   - `user_metadata` anywhere in the policy (VULNERABLE - must fix)

3. Apply the SECURE pattern from migration 20260127000001:
   - Replace user_metadata role checks with `public.is_admin()` or database table queries
   - Wrap auth.uid() in (SELECT auth.uid()) for performance
   - Use EXISTS subqueries to check table membership

4. If is_admin() function doesn't exist, create it (from 20260127000001 pattern)

5. Create indexes for columns used in RLS checks if not already indexed

Expected tables to audit: students, teachers, students_score, student_skill_progress, student_daily_goals, teacher_student_connections, accessories, user_accessories, student_point_transactions, practice_sessions, class_enrollments, assignments, assignment_submissions, notifications

Migration must be idempotent (DROP POLICY IF EXISTS before CREATE POLICY).
  </action>
  <verify>
Run: `grep -i "user_metadata" supabase/migrations/20260131000001_audit_rls_policies.sql` should return NO matches (we're removing, not adding user_metadata usage).
Run: `grep -c "is_admin\|auth.uid()\|EXISTS.*FROM.*students\|EXISTS.*FROM.*teachers" supabase/migrations/20260131000001_audit_rls_policies.sql` should return positive count showing secure patterns.
  </verify>
  <done>
Migration file exists, uses only database state for authorization (is_admin(), table EXISTS checks), no user_metadata references, all policies are idempotent (DROP IF EXISTS + CREATE).
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit and fix SECURITY DEFINER functions (SEC-02)</name>
  <files>supabase/migrations/20260131000002_audit_security_definer.sql</files>
  <action>
Audit ALL SECURITY DEFINER functions for proper auth.uid() checks. Create a migration that fixes any functions missing authorization verification.

1. Query current SECURITY DEFINER functions:
```sql
SELECT p.proname, p.prosrc, p.proargnames, p.proargtypes
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
AND p.prosecdef = true;
```

2. For EACH SECURITY DEFINER function found:
   - Check if it accepts a user ID parameter (student_id, user_id, teacher_id)
   - Verify it has `IF auth.uid() != param THEN RAISE EXCEPTION` at the start
   - If missing, add the authorization check

3. Apply the SECURE pattern from migration 20260126000001 (award_xp):
```sql
-- At function start, before any data access:
IF auth.uid() IS NULL THEN
  RAISE EXCEPTION 'Not authenticated';
END IF;

IF auth.uid() != p_student_id THEN
  RAISE EXCEPTION 'Unauthorized: You can only access your own data';
END IF;
```

4. For functions that allow teacher access to student data:
   - Add relationship check: EXISTS (SELECT 1 FROM teacher_student_connections WHERE teacher_id = auth.uid() AND student_id = p_student_id AND status = 'accepted')

5. Add COMMENT ON FUNCTION documenting the security requirement

6. Ensure GRANT EXECUTE only to authenticated role (revoke PUBLIC if granted)

Known SECURITY DEFINER functions to audit:
- award_xp (already fixed in 20260126000001)
- is_admin (helper function, no user param - OK)
- Any other functions found in the audit
  </action>
  <verify>
Run: `grep -c "auth.uid()" supabase/migrations/20260131000002_audit_security_definer.sql` should return positive count.
Run: `grep -c "RAISE EXCEPTION" supabase/migrations/20260131000002_audit_security_definer.sql` should return positive count.
Run: `grep -c "GRANT EXECUTE.*authenticated" supabase/migrations/20260131000002_audit_security_definer.sql` should return positive count.
  </verify>
  <done>
Migration file exists. All SECURITY DEFINER functions have auth.uid() verification at start. Functions with user ID params verify caller matches or has valid relationship. GRANT EXECUTE restricted to authenticated role.
  </done>
</task>

</tasks>

<verification>
After both migrations are created:

1. Review migration SQL for correctness:
   - All DROP statements use IF EXISTS
   - All CREATE statements are complete and syntactically valid
   - No circular dependencies between policies

2. Verify no user_metadata patterns remain:
   ```bash
   grep -r "user_metadata" supabase/migrations/2026013*.sql
   # Should return empty or only show removal comments
   ```

3. Verify secure patterns are used:
   ```bash
   grep -c "is_admin\|auth\.uid()" supabase/migrations/2026013*.sql
   # Should return positive counts
   ```
</verification>

<success_criteria>
- Two migration files exist in supabase/migrations/
- RLS policies use database state (is_admin(), table checks) not user_metadata
- All SECURITY DEFINER functions verify auth.uid() before execution
- Migrations are idempotent (safe to run multiple times)
- Patterns match established conventions from 20260126/20260127 migrations
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security-fixes/01-01-SUMMARY.md`
</output>
