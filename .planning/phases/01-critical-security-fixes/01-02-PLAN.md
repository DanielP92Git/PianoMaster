---
phase: 01-critical-security-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/authorizationUtils.js
  - src/services/skillProgressService.js
  - src/services/dailyGoalsService.js
  - src/services/streakService.js
  - src/services/apiTeacher.js
  - src/utils/xpSystem.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All service methods verify user.id matches studentId before database operations"
    - "Teacher access to student data verifies relationship in teacher_student_connections"
    - "Unauthorized access attempts throw descriptive errors (not silent failures)"
  artifacts:
    - path: "src/services/authorizationUtils.js"
      provides: "Shared authorization verification utilities"
      exports: ["verifyStudentDataAccess", "getCurrentUserId"]
    - path: "src/services/skillProgressService.js"
      provides: "Authorization checks on all student progress methods"
      contains: "verifyStudentDataAccess"
    - path: "src/services/dailyGoalsService.js"
      provides: "Authorization checks on daily goals methods"
      contains: "verifyStudentDataAccess"
    - path: "src/services/streakService.js"
      provides: "Authorization checks on streak methods"
      contains: "verifyStudentDataAccess"
  key_links:
    - from: "skillProgressService.js"
      to: "supabase.auth.getUser()"
      via: "verifyStudentDataAccess call before database query"
      pattern: "verifyStudentDataAccess\\(studentId\\)"
    - from: "dailyGoalsService.js"
      to: "supabase.auth.getUser()"
      via: "verifyStudentDataAccess call before database query"
      pattern: "verifyStudentDataAccess\\(studentId\\)"
---

<objective>
Add client-side authorization verification to all service methods that accept studentId parameters, ensuring users can only access their own data (or teacher-connected student data).

Purpose: Defense in depth - even if RLS fails, client-side checks prevent unauthorized data access. Also provides better error messages than RLS rejections.

Output: All service files with authorization checks following the established pattern from apiScores.js.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-security-fixes/01-CONTEXT.md
@.planning/phases/01-critical-security-fixes/01-RESEARCH.md

# Pattern to follow
@src/services/apiScores.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared authorization utility</name>
  <files>src/services/authorizationUtils.js</files>
  <action>
Create a shared authorization utility module that other services can import. This prevents code duplication and ensures consistent authorization logic.

The utility should include:

```javascript
import supabase from './supabase';

/**
 * Verify the current user has access to the specified student's data.
 * - Students can only access their own data
 * - Teachers can access data of connected students
 * @param {string} studentId - The student ID to verify access for
 * @throws {Error} If not authenticated or unauthorized
 * @returns {Promise<{userId: string, isOwner: boolean, isTeacher: boolean}>}
 */
export async function verifyStudentDataAccess(studentId) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    throw new Error('Not authenticated');
  }

  // Students can access their own data
  if (user.id === studentId) {
    return { userId: user.id, isOwner: true, isTeacher: false };
  }

  // Check if user is a teacher connected to this student
  const { data: connection, error } = await supabase
    .from('teacher_student_connections')
    .select('id')
    .eq('teacher_id', user.id)
    .eq('student_id', studentId)
    .eq('status', 'accepted')
    .single();

  if (error || !connection) {
    throw new Error('Unauthorized: No access to this student\'s data');
  }

  return { userId: user.id, isOwner: false, isTeacher: true };
}

/**
 * Get the current authenticated user ID.
 * @throws {Error} If not authenticated
 * @returns {Promise<string>} The user ID
 */
export async function getCurrentUserId() {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    throw new Error('Not authenticated');
  }
  return user.id;
}
```

This centralizes authorization logic and makes it easy to add features like rate limiting or violation logging later.

After creating the file, verify the module can be imported correctly:
Run: `node --input-type=module -e "import { verifyStudentDataAccess, getCurrentUserId } from './src/services/authorizationUtils.js'; console.log('Import successful');"` should print "Import successful" without errors.
  </action>
  <verify>
Run: `grep -c "verifyStudentDataAccess\|getCurrentUserId" src/services/authorizationUtils.js` should return 2+ (function definitions).
Run: `grep -c "throw new Error" src/services/authorizationUtils.js` should return 3+ (error cases).
Run: `node --input-type=module -e "import { verifyStudentDataAccess, getCurrentUserId } from './src/services/authorizationUtils.js'; console.log('OK');"` should succeed without import errors.
  </verify>
  <done>
File exists with verifyStudentDataAccess and getCurrentUserId functions. Both throw descriptive errors on failure. Teacher relationship check uses teacher_student_connections table with status='accepted'. Module imports successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to student progress services</name>
  <files>src/services/skillProgressService.js, src/services/dailyGoalsService.js, src/services/streakService.js</files>
  <action>
Add authorization checks to all service methods that accept studentId parameters.

For each file, add at the top:
```javascript
import { verifyStudentDataAccess } from './authorizationUtils';
```

Then add `await verifyStudentDataAccess(studentId);` as the FIRST LINE inside each function that accepts studentId.

**skillProgressService.js** - Add checks to:
- getStudentProgress(studentId)
- getNodeProgress(studentId, nodeId)
- updateNodeProgress(studentId, nodeId, stars, score)
- getCompletedNodeIds(studentId)
- getAvailableNodes(studentId)
- getNextRecommendedNode(studentId)
- getTrailStats(studentId)
- checkNodeUnlocked(studentId, nodeId)
- resetStudentProgress(studentId)
- getExerciseProgress(studentId, nodeId)
- getNextExerciseIndex(studentId, nodeId, totalExercises)
- updateExerciseProgress(studentId, ...)
- isExerciseCompleted(studentId, nodeId, exerciseIndex)
- getUnitProgress(studentId, unitNumber, category)
- getCurrentUnitForCategory(studentId, category)
- getNextNodeInPath(studentId, currentNodeId)
- getUnitsInCategory(studentId, category)

**dailyGoalsService.js** - Add checks to:
- getTodaysGoals(studentId)
- updateDailyGoalsProgress(studentId, progressUpdate)
- calculateDailyProgress(studentId)
- getDailyGoalsWithProgress(studentId)

**streakService.js** - Add checks to all functions accepting studentId.

Pattern to follow:
```javascript
export const getStudentProgress = async (studentId) => {
  await verifyStudentDataAccess(studentId);  // ADD THIS LINE
  try {
    // ... existing code
  } catch (error) {
    // ... existing error handling
  }
};
```

Note: For functions that call other functions in the same service (like getAvailableNodes calling getCompletedNodeIds), the child function will also check authorization. This is intentional - each public function should verify authorization independently.
  </action>
  <verify>
Run: `grep -c "verifyStudentDataAccess" src/services/skillProgressService.js` should return 17+ (one per function).
Run: `grep -c "verifyStudentDataAccess" src/services/dailyGoalsService.js` should return 4+ (one per function).
Run: `grep -c "import.*authorizationUtils" src/services/skillProgressService.js` should return 1.
  </verify>
  <done>
All three service files import verifyStudentDataAccess. Every function accepting studentId calls verifyStudentDataAccess(studentId) as its first line. Existing functionality is preserved (only authorization check added).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add authorization to teacher and XP services</name>
  <files>src/services/apiTeacher.js, src/utils/xpSystem.js</files>
  <action>
Add authorization checks to teacher service and XP system utility.

**apiTeacher.js** - Review and add checks:
- Functions accessing student data should verify teacher-student connection
- Use verifyStudentDataAccess which already handles the teacher relationship check
- If teacher-specific functions exist (getTeacherStudents, etc.), ensure they verify auth.uid() matches the teacher ID

**xpSystem.js** - Add check to:
- awardXP(studentId, xpAmount) - verify caller is the student themselves OR is a teacher with connection
  - Note: Most XP awards should be self-awarded (from game completion), so prefer strict user.id === studentId check
  - If teacher XP awards are needed, add explicit teacher relationship check

Pattern for strict self-only access:
```javascript
import supabase from '../services/supabase';

export async function awardXP(studentId, xpAmount) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');
  if (user.id !== studentId) {
    throw new Error('Unauthorized: You can only award XP to yourself');
  }
  // ... existing XP logic
}
```

If awardXP doesn't already have this check, add it. The database function (award_xp) already has this check, but defense in depth requires client-side check too.
  </action>
  <verify>
Run: `grep -c "auth.getUser\|verifyStudentDataAccess" src/utils/xpSystem.js` should return 1+.
Run: `grep -c "Unauthorized\|Not authenticated" src/utils/xpSystem.js` should return 2+.
  </verify>
  <done>
xpSystem.js verifies user.id === studentId before awarding XP. apiTeacher.js verifies teacher identity and relationships for student data access. All functions throw descriptive errors on authorization failure.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All service files import authorization utilities:
   ```bash
   grep -l "authorizationUtils\|verifyStudentDataAccess" src/services/*.js src/utils/xpSystem.js
   # Should list all modified files
   ```

2. No studentId parameter is trusted without verification:
   ```bash
   # Spot check: search for functions with studentId that DON'T call verify
   # This should return empty or only helper/internal functions
   ```

3. Error messages are descriptive:
   ```bash
   grep "Unauthorized\|Not authenticated" src/services/*.js src/utils/xpSystem.js
   # Should show all authorization error messages
   ```
</verification>

<success_criteria>
- authorizationUtils.js exists with shared verification functions
- skillProgressService.js, dailyGoalsService.js, streakService.js have authorization checks
- xpSystem.js verifies user identity before XP operations
- All authorization checks use consistent error messages
- Existing functionality preserved (only authorization added)
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security-fixes/01-02-SUMMARY.md`
</output>
