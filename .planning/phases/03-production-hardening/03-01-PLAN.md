---
phase: 03-production-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260201000001_add_rate_limiting.sql
  - src/services/rateLimitService.js
autonomous: true

must_haves:
  truths:
    - "Rate limit check function exists and enforces 10 requests per 5 minutes per student per node"
    - "Advisory lock prevents race conditions on concurrent submissions"
    - "First submission initializes rate limit record, subsequent submissions decrement tokens"
    - "Window resets after 5 minutes of inactivity on that node"
  artifacts:
    - path: "supabase/migrations/20260201000001_add_rate_limiting.sql"
      provides: "rate_limits table and check_rate_limit function"
      contains: "pg_advisory_xact_lock"
    - path: "src/services/rateLimitService.js"
      provides: "Client interface for rate limit checking"
      exports: ["checkRateLimit", "getRateLimitStatus"]
  key_links:
    - from: "src/services/rateLimitService.js"
      to: "check_rate_limit RPC"
      via: "supabase.rpc call"
      pattern: "supabase\\.rpc\\(['\"]check_rate_limit['\"]"
---

<objective>
Create the database-level rate limiting infrastructure that prevents XP farming by limiting score submissions to 10 per 5 minutes per student per node.

Purpose: Database-level enforcement ensures rate limits cannot be bypassed by client-side manipulation. This protects the XP system integrity.
Output: PostgreSQL table, function, RLS policies, and a JavaScript service to interface with them.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-production-hardening/03-RESEARCH.md

Key patterns from research:
- Use pg_advisory_xact_lock for race-free rate limiting
- Fixed window algorithm (reset after 5 minutes since first submission)
- SECURITY DEFINER function must verify auth.uid()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting database migration</name>
  <files>supabase/migrations/20260201000001_add_rate_limiting.sql</files>
  <action>
Create a migration file with:

1. **rate_limits table:**
   - student_id UUID NOT NULL (FK to students)
   - node_id TEXT NOT NULL
   - tokens INTEGER NOT NULL DEFAULT 10
   - last_refill TIMESTAMPTZ NOT NULL DEFAULT NOW()
   - PRIMARY KEY (student_id, node_id)

2. **check_rate_limit function** (SECURITY DEFINER):
   - Parameters: p_student_id UUID, p_node_id TEXT, p_max_requests INTEGER DEFAULT 10, p_window_seconds INTEGER DEFAULT 300
   - Returns BOOLEAN (TRUE = allowed, FALSE = rate limited)
   - MUST verify auth.uid() = p_student_id (authorization check)
   - Use pg_advisory_xact_lock to prevent race conditions
   - Fixed window logic:
     - If no record exists: INSERT with (max_requests - 1) tokens, return TRUE
     - If window expired (elapsed >= window_seconds): reset tokens to max-1, update last_refill, return TRUE
     - If tokens > 0: decrement token, return TRUE
     - Else: return FALSE (rate limited)

3. **RLS policies:**
   - Enable RLS on rate_limits
   - Students can only see/modify their own records: USING (student_id = auth.uid())

4. **Grant permissions:**
   - GRANT SELECT, INSERT, UPDATE ON rate_limits TO authenticated
   - GRANT EXECUTE ON FUNCTION check_rate_limit TO authenticated

5. **Function comments** for documentation
  </action>
  <verify>Run `npx supabase db push --dry-run` to validate SQL syntax. Check that the function includes auth.uid() verification.</verify>
  <done>Migration file exists with rate_limits table, check_rate_limit function with authorization, and RLS policies.</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limit service</name>
  <files>src/services/rateLimitService.js</files>
  <action>
Create a service file with two exported functions:

1. **checkRateLimit(studentId, nodeId):**
   - Call supabase.rpc('check_rate_limit', { p_student_id, p_node_id, p_max_requests: 10, p_window_seconds: 300 })
   - If allowed (data === true), return { allowed: true, resetTime: null }
   - If rate limited (data === false):
     - Query rate_limits table for last_refill timestamp
     - Calculate resetTime = last_refill + 5 minutes
     - Return { allowed: false, resetTime: Date }
   - Handle errors by logging and re-throwing

2. **getRateLimitStatus(studentId, nodeId):**
   - Query rate_limits table for tokens and last_refill
   - If no record, return { tokens: 10, resetTime: new Date() }
   - Calculate resetTime = last_refill + 5 minutes
   - Return { tokens, resetTime }

Import supabase from './supabase'.
Follow existing service patterns in the codebase.
  </action>
  <verify>Check that imports are correct and function signatures match the JSDoc. Verify supabase.rpc call uses correct parameter names (p_student_id, p_node_id).</verify>
  <done>rateLimitService.js exports checkRateLimit and getRateLimitStatus functions that interface with database.</done>
</task>

</tasks>

<verification>
1. Migration file exists and contains:
   - CREATE TABLE rate_limits
   - CREATE OR REPLACE FUNCTION check_rate_limit with SECURITY DEFINER
   - pg_advisory_xact_lock for race prevention
   - IF auth.uid() != p_student_id THEN RAISE EXCEPTION for authorization
   - RLS policies with student_id = auth.uid()

2. Service file exports both functions and calls supabase.rpc correctly
</verification>

<success_criteria>
- Rate limiting database layer is ready for deployment
- Client service can call rate limit check before score submissions
- Authorization enforced at database level (self-only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-production-hardening/03-01-SUMMARY.md`
</output>
