---
phase: 15-victoryscreen-celebration-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/celebrationTiers.js
  - src/utils/celebrationMessages.js
  - src/components/celebrations/ConfettiEffect.jsx
autonomous: true

must_haves:
  truths:
    - "determineCelebrationTier returns correct tier for each star/boss/levelUp combination"
    - "getCelebrationMessage returns node-type-specific title and subtitle for all 8 node types"
    - "getCelebrationMessage returns generic star-based messages when nodeType is null (free play mode)"
    - "ConfettiEffect renders react-confetti with tier-based particle counts and skips entirely in reducedMotion"
  artifacts:
    - path: "src/utils/celebrationTiers.js"
      provides: "Tier determination logic and tier configuration"
      exports: ["determineCelebrationTier", "getCelebrationConfig"]
    - path: "src/utils/celebrationMessages.js"
      provides: "Node-type-specific celebration messages for 8 types"
      exports: ["getCelebrationMessage"]
    - path: "src/components/celebrations/ConfettiEffect.jsx"
      provides: "Accessible confetti component wrapping react-confetti"
      exports: ["ConfettiEffect"]
  key_links:
    - from: "src/utils/celebrationTiers.js"
      to: "src/utils/celebrationConstants.js"
      via: "Duration tier mapping"
      pattern: "CELEBRATION_TIERS"
    - from: "src/utils/celebrationMessages.js"
      to: "src/data/nodeTypes.js"
      via: "NODE_TYPES import"
      pattern: "NODE_TYPES"
    - from: "src/components/celebrations/ConfettiEffect.jsx"
      to: "react-confetti"
      via: "import Confetti"
      pattern: "from 'react-confetti'"
---

<objective>
Create the celebration utility layer: tier determination logic, node-type-specific messages, and an accessible confetti component.

Purpose: These utilities and components are the building blocks that VictoryScreen (Plan 03) will consume. By creating them independently first, we keep the VictoryScreen integration plan focused and small.

Output: Three new files providing celebration tier logic, message mapping, and confetti effects.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-victoryscreen-celebration-system/15-RESEARCH.md

Key existing files to reference:
@src/utils/celebrationConstants.js
@src/data/nodeTypes.js
@src/components/celebrations/CelebrationWrapper.jsx
@src/components/celebrations/useCelebrationDuration.js
@src/contexts/AccessibilityContext.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create celebration tier logic and node-type messages</name>
  <files>src/utils/celebrationTiers.js, src/utils/celebrationMessages.js</files>
  <action>
Create two utility files:

**src/utils/celebrationTiers.js:**

Export `determineCelebrationTier(stars, isBoss, leveledUp, scorePercentage)`:
- Returns `'epic'` if isBoss AND stars >= 1
- Returns `'full'` if stars === 3 OR leveledUp is true
- Returns `'standard'` if stars >= 1
- Returns `'minimal'` otherwise (< 60% score, 0 stars)

Export `getCelebrationConfig(tier)`:
- `minimal`: { duration: 'standard', confetti: false, animation: 'fade', messageIntensity: 'neutral' }
- `standard`: { duration: 'standard', confetti: false, animation: 'bounce', messageIntensity: 'positive' }
- `full`: { duration: 'level-up', confetti: true, animation: 'bounce-glow', messageIntensity: 'excellent' }
- `epic`: { duration: 'boss', confetti: true, animation: 'epic', messageIntensity: 'epic' }

The `duration` values map directly to CELEBRATION_TIERS keys from celebrationConstants.js. Import and reference them in a JSDoc comment so the mapping is explicit.

**src/utils/celebrationMessages.js:**

Import NODE_TYPES from `../../data/nodeTypes` (NOTE: relative path from utils/ to data/).

Export `getCelebrationMessage(nodeType, stars, isBoss)`:
- If isBoss AND stars >= 1: return { title: stars === 3 ? 'PERFECT VICTORY!' : 'BOSS DEFEATED!', subtitle: 'You conquered the challenge!' }
- If stars === 3, use node-type-specific messages:
  - DISCOVERY: { title: 'NEW NOTES MASTERED!', subtitle: "You learned something new!" }
  - PRACTICE: { title: 'PRACTICE PERFECT!', subtitle: "You're getting really good!" }
  - MIX_UP: { title: 'GAME CHAMPION!', subtitle: 'You aced the memory game!' }
  - SPEED_ROUND: { title: 'LIGHTNING FAST!', subtitle: 'Wow, you beat the clock!' }
  - REVIEW: { title: 'YOU REMEMBERED!', subtitle: 'Those notes stuck with you!' }
  - CHALLENGE: { title: 'CHALLENGE CRUSHED!', subtitle: 'That was a tough one!' }
  - MINI_BOSS: { title: 'MINI-BOSS DOWN!', subtitle: 'Unit checkpoint completed!' }
  - Fallback (unknown type or null): { title: 'PERFECT!', subtitle: 'You got every single one!' }
- If stars === 2: { title: 'Great Job!', subtitle: 'You did really well!' }
- If stars === 1: { title: 'Good Try!', subtitle: 'Keep practicing!' }
- If stars === 0: { title: 'Nice Effort!', subtitle: 'Try again to earn stars!' }

IMPORTANT: Handle null/undefined nodeType gracefully -- fall through to generic star-based messages. Free play mode (nodeId is null) means nodeType will be null.

Use hardcoded English strings (not i18n keys) per research recommendation.
  </action>
  <verify>
Run: `node -e "const t = require('./src/utils/celebrationTiers.js'); console.log(t.determineCelebrationTier(3, false, false, 95));"` -- should output 'full'. If ESM prevents direct require, verify by checking file exists and has correct exports via grep.

Verify all 8 NODE_TYPES are covered in celebrationMessages.js: `grep -c "NODE_TYPES\." src/utils/celebrationMessages.js` should return at least 7 (BOSS handled separately).
  </verify>
  <done>
- celebrationTiers.js exports determineCelebrationTier and getCelebrationConfig
- celebrationMessages.js exports getCelebrationMessage
- All 8 node types have unique 3-star messages
- Boss override works (isBoss + stars >= 1 returns epic message)
- Null nodeType falls back to generic star-based messages
  </done>
</task>

<task type="auto">
  <name>Task 2: Create accessible ConfettiEffect component</name>
  <files>src/components/celebrations/ConfettiEffect.jsx</files>
  <action>
Create a React component that wraps react-confetti (already installed at v6.2.3).

**ConfettiEffect component:**

Props:
- `tier` (string): 'full' or 'epic' -- determines particle configuration
- `onComplete` (function): Called when confetti animation finishes

Implementation:
1. Import `Confetti` from 'react-confetti'
2. Import `useAccessibility` from `../../contexts/AccessibilityContext`
3. Use local state for window dimensions (width/height), initialized from `window.innerWidth` and `window.innerHeight`
4. Add resize event listener in useEffect (cleanup on unmount)
5. Use `useState` for `isRunning` (starts true)

**Reduced motion handling:**
- If `reducedMotion` is true, do NOT render any confetti. Call `onComplete?.()` via useEffect and return null.
- IMPORTANT: The reducedMotion check must happen BEFORE any hooks that conditionally run. Structure the component so all hooks are called unconditionally at the top, then return null after hooks if reducedMotion is true.

**Tier-based configuration:**
- `epic` tier: numberOfPieces=500, gravity=0.3, initialVelocityY=20, colors=['#FFD700', '#FFA500', '#FF6347', '#87CEEB', '#9370DB']
- `full` tier: numberOfPieces=200, gravity=0.5, initialVelocityY=15, colors=['#FFD700', '#FFA500', '#87CEEB', '#98FB98']

**Both tiers:** recycle=false (confetti falls and stops, does not loop)

**Auto-stop:** Use `onConfettiComplete` prop from react-confetti to detect when all particles have fallen. This is cleaner than a manual setTimeout. When onConfettiComplete fires, set isRunning to false and call onComplete.

**Render:**
```jsx
<div className="fixed inset-0 pointer-events-none z-[9998]">
  <Confetti
    width={windowSize.width}
    height={windowSize.height}
    numberOfPieces={isRunning ? config.numberOfPieces : 0}
    recycle={false}
    gravity={config.gravity}
    initialVelocityY={config.initialVelocityY}
    colors={config.colors}
    onConfettiComplete={handleComplete}
  />
</div>
```

Use z-[9998] so confetti appears behind VictoryScreen's z-[9999] content but above everything else.

Export as named export: `export function ConfettiEffect({ ... })`.
  </action>
  <verify>
Verify file exists and imports react-confetti: `grep "from 'react-confetti'" src/components/celebrations/ConfettiEffect.jsx`

Verify reducedMotion check exists: `grep "reducedMotion" src/components/celebrations/ConfettiEffect.jsx`

Verify both tier configs exist: `grep "numberOfPieces" src/components/celebrations/ConfettiEffect.jsx` should show two different values (200 and 500).

Run `npm run lint` to confirm no lint errors.
  </verify>
  <done>
- ConfettiEffect.jsx renders react-confetti with tier-based configuration
- Returns null and calls onComplete immediately when reducedMotion is true
- All hooks called unconditionally (no conditional hook calls)
- z-index 9998 (below VictoryScreen 9999 content, above everything else)
- Uses onConfettiComplete callback for clean animation completion detection
  </done>
</task>

</tasks>

<verification>
- `npm run lint` passes with no errors in new files
- `npm run build` succeeds (no import/export issues)
- All three files exist with correct named exports
- celebrationTiers.js references CELEBRATION_TIERS keys correctly
- celebrationMessages.js covers all 8 NODE_TYPES
- ConfettiEffect respects reducedMotion accessibility setting
</verification>

<success_criteria>
Three new utility/component files exist providing celebration tier logic, node-type-specific messages, and accessible confetti effects. All files have correct imports, exports, and no lint errors. These are ready to be consumed by VictoryScreen in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/15-victoryscreen-celebration-system/15-01-SUMMARY.md`
</output>
