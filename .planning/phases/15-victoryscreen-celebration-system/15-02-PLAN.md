---
phase: 15-victoryscreen-celebration-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260208000001_add_score_percentile_function.sql
  - src/services/scoreComparisonService.js
autonomous: true

must_haves:
  truths:
    - "Percentile calculation returns a number 0-100 representing how current score compares to student's history"
    - "Percentile falls back to null when fewer than 3 historical attempts exist for the node"
    - "Percentile query does not block VictoryScreen rendering (async, non-blocking)"
    - "Child-friendly percentile messages vary by tier (90%+, 70%+, 50%+, 25%+, below 25%)"
  artifacts:
    - path: "supabase/migrations/20260208000001_add_score_percentile_function.sql"
      provides: "PostgreSQL function for PERCENT_RANK calculation"
      contains: "calculate_score_percentile"
    - path: "src/services/scoreComparisonService.js"
      provides: "Client-side service for score percentile and messaging"
      exports: ["calculateScorePercentile", "getPercentileMessage"]
  key_links:
    - from: "src/services/scoreComparisonService.js"
      to: "supabase rpc"
      via: "supabase.rpc('calculate_score_percentile')"
      pattern: "supabase\\.rpc.*calculate_score_percentile"
    - from: "src/services/scoreComparisonService.js"
      to: "src/services/authorizationUtils.js"
      via: "verifyStudentDataAccess import"
      pattern: "verifyStudentDataAccess"
---

<objective>
Create the percentile comparison system: a PostgreSQL function using PERCENT_RANK() and a client service that calls it and generates child-friendly comparison messages.

Purpose: Requirement CELEB-09 needs "Better than X% of your previous scores" display. This requires a database function (efficient server-side percentile calculation) and a service layer (async call + message generation). Building this in parallel with Plan 01 (Wave 1) since they share no files.

Output: One SQL migration file and one JS service file.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-victoryscreen-celebration-system/15-RESEARCH.md

Key existing files to reference:
@supabase/migrations/20260124000001_add_skill_trail_system.sql
@src/services/skillProgressService.js
@src/services/authorizationUtils.js
@src/services/supabase.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL percentile function and client service</name>
  <files>supabase/migrations/20260208000001_add_score_percentile_function.sql, src/services/scoreComparisonService.js</files>
  <action>
**SQL Migration: supabase/migrations/20260208000001_add_score_percentile_function.sql**

Create a PostgreSQL function `calculate_score_percentile` that:

```sql
CREATE OR REPLACE FUNCTION calculate_score_percentile(
  p_student_id UUID,
  p_current_score INTEGER,
  p_node_id TEXT
)
RETURNS JSONB AS $$
DECLARE
  v_historical_count INTEGER;
  v_percentile_rank DECIMAL;
BEGIN
  -- Authorization: user can only calculate their own percentile
  IF auth.uid() != p_student_id THEN
    RAISE EXCEPTION 'Unauthorized: Cannot access another student''s data';
  END IF;

  -- Count historical scores for this node
  -- Use student_skill_progress.best_score for trail nodes
  SELECT COUNT(*)
  INTO v_historical_count
  FROM student_skill_progress
  WHERE student_id = p_student_id
    AND node_id != p_node_id
    AND best_score > 0;

  -- Also count the current node's previous score if it exists
  SELECT v_historical_count + COUNT(*)
  INTO v_historical_count
  FROM student_skill_progress
  WHERE student_id = p_student_id
    AND node_id = p_node_id
    AND best_score > 0;

  -- If fewer than 3 historical attempts, return null (not enough data for meaningful percentile)
  IF v_historical_count < 3 THEN
    RETURN jsonb_build_object('percentile', NULL, 'insufficient_data', true, 'count', v_historical_count);
  END IF;

  -- Calculate percentile rank of current score against ALL student's trail scores
  -- This compares: "How does this score rank against all your past trail attempts?"
  SELECT COALESCE(
    (SELECT pct FROM (
      SELECT best_score, PERCENT_RANK() OVER (ORDER BY best_score) as pct
      FROM (
        SELECT best_score FROM student_skill_progress
        WHERE student_id = p_student_id
          AND best_score > 0
        UNION ALL
        SELECT p_current_score AS best_score
      ) all_scores
    ) ranked
    WHERE best_score = p_current_score
    ORDER BY pct DESC
    LIMIT 1), 0)
  INTO v_percentile_rank;

  RETURN jsonb_build_object(
    'percentile', ROUND(v_percentile_rank * 100),
    'insufficient_data', false,
    'count', v_historical_count
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER
   SET search_path = public;
```

Grant execute to authenticated users:
```sql
GRANT EXECUTE ON FUNCTION calculate_score_percentile(UUID, INTEGER, TEXT) TO authenticated;
```

Add a comment:
```sql
COMMENT ON FUNCTION calculate_score_percentile IS
  'Calculates percentile rank of a score against student''s historical trail scores. Returns null if fewer than 3 historical attempts exist.';
```

IMPORTANT: The function uses SECURITY DEFINER but includes `auth.uid()` authorization check (following the project's security hardening guidelines). Also sets `search_path = public` per the project's convention for avoiding search_path warnings (see migration 20260127000002).

**Client Service: src/services/scoreComparisonService.js**

Import supabase from './supabase' and verifyStudentDataAccess from './authorizationUtils'.

Export `calculateScorePercentile(studentId, currentScore, nodeId)`:
1. Call `await verifyStudentDataAccess(studentId)` for client-side authorization check (defense in depth)
2. Call `supabase.rpc('calculate_score_percentile', { p_student_id: studentId, p_current_score: currentScore, p_node_id: nodeId })`
3. Parse the JSONB response
4. If `insufficient_data` is true or error occurs, return null
5. Return the percentile number (0-100)
6. Wrap entire function in try/catch -- percentile is non-critical, return null on any error (do NOT throw)

Export `getPercentileMessage(percentile)`:
- If percentile is null or undefined, return null
- >= 90: "Your best score yet! Better than {percentile}% of your attempts!"
- >= 70: "Great improvement! Better than {percentile}% of your previous scores!"
- >= 50: "You're getting better! Beat {percentile}% of your past tries!"
- >= 25: "Keep practicing! Better than {percentile}% of before!"
- < 25: "Room to grow! Keep trying!"

NO emojis in message strings. Keep them simple, child-friendly, English only.

IMPORTANT: This service is designed to be called asynchronously from VictoryScreen WITHOUT blocking render. The VictoryScreen integration (Plan 03) will call this in a background useEffect and update state when the result arrives.
  </action>
  <verify>
Verify SQL file exists and contains required elements:
- `grep "calculate_score_percentile" supabase/migrations/20260208000001_add_score_percentile_function.sql`
- `grep "auth.uid()" supabase/migrations/20260208000001_add_score_percentile_function.sql` -- authorization check present
- `grep "PERCENT_RANK" supabase/migrations/20260208000001_add_score_percentile_function.sql`
- `grep "search_path" supabase/migrations/20260208000001_add_score_percentile_function.sql`

Verify JS service file:
- `grep "verifyStudentDataAccess" src/services/scoreComparisonService.js` -- authorization present
- `grep "supabase.rpc" src/services/scoreComparisonService.js` -- calls the function
- `grep "getPercentileMessage" src/services/scoreComparisonService.js` -- message function exists

Run `npm run lint` to confirm no lint errors in new JS file.
  </verify>
  <done>
- SQL migration creates calculate_score_percentile function with auth check and PERCENT_RANK
- Function returns null when fewer than 3 historical attempts exist
- Client service exports calculateScorePercentile and getPercentileMessage
- Client service has defense-in-depth authorization (verifyStudentDataAccess)
- All errors caught gracefully (returns null, never throws)
- Message tiers cover all percentile ranges with child-friendly English text
  </done>
</task>

</tasks>

<verification>
- `npm run lint` passes with no errors in new service file
- `npm run build` succeeds
- SQL migration file is syntactically valid SQL
- SQL function includes auth.uid() check (security requirement)
- SQL function includes search_path = public (convention)
- Client service never throws -- all errors return null
</verification>

<success_criteria>
A PostgreSQL migration file and a client service file exist. The SQL function calculates percentile rank using PERCENT_RANK() with authorization checks. The client service calls the function asynchronously and returns null on any error. The percentile message function produces child-friendly English strings. Both files are lint-clean and ready for VictoryScreen integration in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/15-victoryscreen-celebration-system/15-02-SUMMARY.md`
</output>
