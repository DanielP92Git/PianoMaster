---
phase: 02-coppa-compliance
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/consentService.js
  - src/services/dataExportService.js
  - src/services/accountDeletionService.js
autonomous: true

must_haves:
  truths:
    - "Consent tokens can be generated with 7-day expiry"
    - "Consent tokens can be verified and marked as used"
    - "Student data can be exported as JSON blob"
    - "Accounts can be soft-deleted with 30-day grace period"
  artifacts:
    - path: "src/services/consentService.js"
      provides: "Parental consent token operations"
      exports: ["sendParentalConsentEmail", "verifyParentalConsent", "resendConsentEmail", "revokeConsent"]
    - path: "src/services/dataExportService.js"
      provides: "COPPA data export operations"
      exports: ["exportStudentData", "downloadStudentDataJSON"]
    - path: "src/services/accountDeletionService.js"
      provides: "Account deletion with soft delete"
      exports: ["requestAccountDeletion", "cancelDeletionRequest", "getAccountDeletionStatus"]
  key_links:
    - from: "consentService.js"
      to: "parental_consent_tokens"
      via: "supabase query"
      pattern: "from\\('parental_consent_tokens'\\)"
    - from: "dataExportService.js"
      to: "multiple tables"
      via: "parallel queries"
      pattern: "Promise\\.all"
---

<objective>
Create COPPA compliance services: parental consent management, data export, and account deletion with soft delete grace period.

Purpose: Enable COPPA rights - parental consent verification, right to access (export), right to deletion
Output: Three service modules handling consent, export, and deletion operations
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-coppa-compliance/02-CONTEXT.md
@.planning/phases/02-coppa-compliance/02-RESEARCH.md
@.planning/phases/02-coppa-compliance/02-01-SUMMARY.md
@src/services/authService.js
@src/services/skillProgressService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Consent Service</name>
  <files>src/services/consentService.js</files>
  <action>
Create the parental consent service with token-based verification:

```javascript
import supabase from './supabase';

/**
 * Hash a token using Web Crypto API
 */
async function hashToken(token) {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Generate a consent token and send email to parent
 * @param {string} studentId - Student UUID
 * @param {string} parentEmail - Parent's email address
 */
export async function sendParentalConsentEmail(studentId, parentEmail) {
  // Verify caller has access to this student
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  // Generate secure token
  const token = crypto.randomUUID();
  const tokenHash = await hashToken(token);
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

  // Store token
  const { error: tokenError } = await supabase
    .from('parental_consent_tokens')
    .insert({
      student_id: studentId,
      token_hash: tokenHash,
      expires_at: expiresAt.toISOString()
    });

  if (tokenError) throw tokenError;

  // Log consent request
  await supabase.from('parental_consent_log').insert({
    student_id: studentId,
    parent_email: parentEmail,
    action: 'requested'
  });

  // Build consent URL
  const consentUrl = `${window.location.origin}/consent/verify?token=${token}&student=${studentId}`;

  // TODO: Send actual email via Supabase Edge Function or email service
  // For now, log the URL for development
  console.log('[DEV] Consent verification URL:', consentUrl);

  return { consentUrl, expiresAt };
}

/**
 * Verify parental consent token and activate account
 * @param {string} studentId - Student UUID
 * @param {string} token - Consent token from email
 */
export async function verifyParentalConsent(studentId, token) {
  const tokenHash = await hashToken(token);

  // Find valid token
  const { data: consentToken, error: findError } = await supabase
    .from('parental_consent_tokens')
    .select('*, students!inner(parent_email)')
    .eq('student_id', studentId)
    .eq('token_hash', tokenHash)
    .is('used_at', null)
    .gt('expires_at', new Date().toISOString())
    .single();

  if (findError || !consentToken) {
    throw new Error('Invalid or expired consent token');
  }

  // Mark token as used
  const { error: updateTokenError } = await supabase
    .from('parental_consent_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('id', consentToken.id);

  if (updateTokenError) throw updateTokenError;

  // Activate account
  const { error: activateError } = await supabase
    .from('students')
    .update({
      account_status: 'active',
      consent_verified_at: new Date().toISOString()
    })
    .eq('id', studentId);

  if (activateError) throw activateError;

  // Log verification
  await supabase.from('parental_consent_log').insert({
    student_id: studentId,
    parent_email: consentToken.students.parent_email,
    action: 'verified'
  });

  return { success: true };
}

/**
 * Resend consent email (invalidates previous tokens)
 */
export async function resendConsentEmail(studentId) {
  // Get student's parent email
  const { data: student, error } = await supabase
    .from('students')
    .select('parent_email')
    .eq('id', studentId)
    .single();

  if (error || !student?.parent_email) {
    throw new Error('Student not found or no parent email');
  }

  // Mark all existing tokens as expired
  await supabase
    .from('parental_consent_tokens')
    .update({ used_at: new Date().toISOString() })
    .eq('student_id', studentId)
    .is('used_at', null);

  // Send new consent email
  return sendParentalConsentEmail(studentId, student.parent_email);
}

/**
 * Revoke parental consent (triggers account deletion)
 */
export async function revokeConsent(studentId) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');

  // Get student info
  const { data: student } = await supabase
    .from('students')
    .select('parent_email')
    .eq('id', studentId)
    .single();

  // Update account status
  const { error } = await supabase
    .from('students')
    .update({
      consent_revoked_at: new Date().toISOString(),
      account_status: 'suspended_deletion',
      deletion_requested_at: new Date().toISOString(),
      deletion_scheduled_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
    })
    .eq('id', studentId);

  if (error) throw error;

  // Log revocation
  await supabase.from('parental_consent_log').insert({
    student_id: studentId,
    parent_email: student?.parent_email || 'unknown',
    action: 'revoked'
  });

  return { success: true };
}

/**
 * Get consent status for a student
 */
export async function getConsentStatus(studentId) {
  const { data, error } = await supabase
    .from('students')
    .select('account_status, consent_verified_at, parent_email, is_under_13')
    .eq('id', studentId)
    .single();

  if (error) throw error;

  return {
    isUnder13: data.is_under_13,
    needsConsent: data.is_under_13 && !data.consent_verified_at,
    consentVerified: !!data.consent_verified_at,
    parentEmail: data.parent_email,
    accountStatus: data.account_status
  };
}
```

Use Web Crypto API for token hashing (browser-native, secure).
Follow existing service patterns from authService.js and skillProgressService.js.
  </action>
  <verify>
File exists at src/services/consentService.js
Exports: sendParentalConsentEmail, verifyParentalConsent, resendConsentEmail, revokeConsent, getConsentStatus
Uses crypto.subtle.digest for secure hashing
Logs all consent events to parental_consent_log
  </verify>
  <done>
Consent service handles full token lifecycle: generation, verification, expiry, revocation with audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Data Export Service</name>
  <files>src/services/dataExportService.js</files>
  <action>
Create the COPPA data export service:

```javascript
import supabase from './supabase';
import { verifyStudentDataAccess } from './authService';

/**
 * Tables that contain student data (must be kept in sync with schema)
 */
const STUDENT_DATA_TABLES = [
  { table: 'students', idColumn: 'id' },
  { table: 'students_score', idColumn: 'student_id' },
  { table: 'student_skill_progress', idColumn: 'student_id' },
  { table: 'student_daily_goals', idColumn: 'student_id' },
  { table: 'practice_sessions', idColumn: 'student_id' },
  { table: 'student_achievements', idColumn: 'student_id' },
  { table: 'assignment_submissions', idColumn: 'student_id' },
  { table: 'parental_consent_log', idColumn: 'student_id' },
  { table: 'student_point_transactions', idColumn: 'student_id' },
  { table: 'user_accessories', idColumn: 'user_id' }
];

/**
 * Export all student data as JSON object
 * @param {string} studentId - Student UUID
 * @returns {Object} All student data
 */
export async function exportStudentData(studentId) {
  // Verify caller has access
  await verifyStudentDataAccess(studentId);

  // Gather all data in parallel
  const queries = STUDENT_DATA_TABLES.map(async ({ table, idColumn }) => {
    try {
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .eq(idColumn, studentId);

      if (error) {
        console.warn(`Error fetching ${table}:`, error.message);
        return { table, data: [], error: error.message };
      }
      return { table, data: data || [] };
    } catch (err) {
      return { table, data: [], error: err.message };
    }
  });

  const results = await Promise.all(queries);

  // Build export object
  const exportData = {
    exportMetadata: {
      exportDate: new Date().toISOString(),
      studentId: studentId,
      exportVersion: '1.0',
      tablesIncluded: STUDENT_DATA_TABLES.map(t => t.table)
    }
  };

  // Add each table's data
  results.forEach(({ table, data, error }) => {
    exportData[table] = {
      recordCount: data.length,
      data: data,
      ...(error && { error })
    };
  });

  return exportData;
}

/**
 * Download student data as JSON file
 * @param {string} studentId - Student UUID
 * @returns {string} Download URL (blob URL)
 */
export async function downloadStudentDataJSON(studentId) {
  const data = await exportStudentData(studentId);

  // Create downloadable blob
  const blob = new Blob(
    [JSON.stringify(data, null, 2)],
    { type: 'application/json' }
  );

  return URL.createObjectURL(blob);
}

/**
 * Get list of tables included in export (for privacy dashboard)
 */
export function getExportedDataTypes() {
  return STUDENT_DATA_TABLES.map(({ table }) => ({
    table,
    description: getTableDescription(table)
  }));
}

function getTableDescription(table) {
  const descriptions = {
    students: 'Your profile information (name, email, level)',
    students_score: 'Your game scores and performance history',
    student_skill_progress: 'Your progress on skill trail nodes',
    student_daily_goals: 'Your daily practice goals',
    practice_sessions: 'Your practice session recordings',
    student_achievements: 'Your unlocked achievements',
    assignment_submissions: 'Your assignment submissions',
    parental_consent_log: 'Consent history (for under-13 users)',
    student_point_transactions: 'Your point earnings and spending',
    user_accessories: 'Your avatar accessories and customizations'
  };
  return descriptions[table] || table;
}
```

Keep STUDENT_DATA_TABLES list in sync with schema - add note for future maintainers.
  </action>
  <verify>
File exists at src/services/dataExportService.js
Exports: exportStudentData, downloadStudentDataJSON, getExportedDataTypes
Queries all student data tables in parallel
Includes export metadata with timestamp and version
  </verify>
  <done>
Data export service gathers all student data from all tables and provides JSON download capability.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Account Deletion Service</name>
  <files>src/services/accountDeletionService.js</files>
  <action>
Create the soft delete service with 30-day grace period:

```javascript
import supabase from './supabase';
import { verifyStudentDataAccess } from './authService';

/**
 * Request account deletion (30-day soft delete)
 * @param {string} studentId - Student UUID
 * @param {string} confirmationName - Must match student's name
 */
export async function requestAccountDeletion(studentId, confirmationName) {
  // Verify access
  await verifyStudentDataAccess(studentId);

  // Get student's name for confirmation
  const { data: student, error: fetchError } = await supabase
    .from('students')
    .select('first_name, last_name, username, account_status')
    .eq('id', studentId)
    .single();

  if (fetchError || !student) {
    throw new Error('Student not found');
  }

  if (student.account_status === 'deleted' || student.account_status === 'suspended_deletion') {
    throw new Error('Account is already deleted or pending deletion');
  }

  // Verify confirmation name matches
  const expectedName = `${student.first_name || ''} ${student.last_name || ''}`.trim() || student.username;
  if (confirmationName.toLowerCase().trim() !== expectedName.toLowerCase()) {
    throw new Error('Account name does not match. Please type the account name exactly.');
  }

  // Calculate deletion date (30 days from now)
  const deletionDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

  // Soft delete - update status and schedule deletion
  const { error: updateError } = await supabase
    .from('students')
    .update({
      account_status: 'suspended_deletion',
      deletion_requested_at: new Date().toISOString(),
      deletion_scheduled_at: deletionDate.toISOString()
    })
    .eq('id', studentId);

  if (updateError) throw updateError;

  // Sign out the user
  await supabase.auth.signOut();

  return {
    success: true,
    scheduledDeletion: deletionDate,
    message: `Account scheduled for deletion on ${deletionDate.toLocaleDateString()}`
  };
}

/**
 * Cancel a pending deletion request (during 30-day grace period)
 * @param {string} studentId - Student UUID
 */
export async function cancelDeletionRequest(studentId) {
  // Verify access
  await verifyStudentDataAccess(studentId);

  // Check current status
  const { data: student, error: fetchError } = await supabase
    .from('students')
    .select('account_status, deletion_scheduled_at')
    .eq('id', studentId)
    .single();

  if (fetchError || !student) {
    throw new Error('Student not found');
  }

  if (student.account_status !== 'suspended_deletion') {
    throw new Error('No pending deletion to cancel');
  }

  // Check if still in grace period
  if (new Date(student.deletion_scheduled_at) < new Date()) {
    throw new Error('Grace period has expired. Account cannot be recovered.');
  }

  // Restore account
  const { error: updateError } = await supabase
    .from('students')
    .update({
      account_status: 'active',
      deletion_requested_at: null,
      deletion_scheduled_at: null
    })
    .eq('id', studentId);

  if (updateError) throw updateError;

  return { success: true, message: 'Deletion cancelled. Your account has been restored.' };
}

/**
 * Get deletion status for an account
 * @param {string} studentId - Student UUID
 */
export async function getAccountDeletionStatus(studentId) {
  const { data, error } = await supabase
    .from('students')
    .select('account_status, deletion_requested_at, deletion_scheduled_at')
    .eq('id', studentId)
    .single();

  if (error) throw error;

  const isPendingDeletion = data.account_status === 'suspended_deletion';
  const daysRemaining = isPendingDeletion && data.deletion_scheduled_at
    ? Math.ceil((new Date(data.deletion_scheduled_at) - new Date()) / (24 * 60 * 60 * 1000))
    : null;

  return {
    isPendingDeletion,
    deletionRequestedAt: data.deletion_requested_at,
    scheduledDeletionAt: data.deletion_scheduled_at,
    daysRemaining,
    canCancel: isPendingDeletion && daysRemaining > 0
  };
}

/**
 * NOTE: Hard deletion is handled by a scheduled Supabase Edge Function
 * that runs daily and deletes accounts where:
 * - account_status = 'suspended_deletion'
 * - deletion_scheduled_at < NOW()
 *
 * The Edge Function will:
 * 1. Delete from students table (CASCADE handles related data)
 * 2. Delete from auth.users using admin API
 */
```

Include note about scheduled hard delete function that will be needed in production.
  </action>
  <verify>
File exists at src/services/accountDeletionService.js
Exports: requestAccountDeletion, cancelDeletionRequest, getAccountDeletionStatus
Requires name confirmation before deletion
Sets 30-day grace period
Allows cancellation during grace period
  </verify>
  <done>
Account deletion service implements soft delete with 30-day grace period, name confirmation, and cancellation capability.
  </done>
</task>

</tasks>

<verification>
- [ ] src/services/consentService.js exists with all exports
- [ ] src/services/dataExportService.js exists with all exports
- [ ] src/services/accountDeletionService.js exists with all exports
- [ ] Consent service uses secure token hashing (crypto.subtle)
- [ ] Consent service logs all events to parental_consent_log
- [ ] Export service queries all student data tables
- [ ] Deletion service requires name confirmation
- [ ] Deletion service sets 30-day grace period
</verification>

<success_criteria>
Services enable: parental consent verification flow, COPPA right-to-access (data export), and COPPA right-to-deletion (with recovery period).
</success_criteria>

<output>
After completion, create `.planning/phases/02-coppa-compliance/02-04-SUMMARY.md`
</output>
