---
phase: 03-game-layout-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useVexFlowResize.js
  - src/components/games/sight-reading-game/components/VexFlowStaffDisplay.jsx
autonomous: true

must_haves:
  truths:
    - "VexFlow notation re-renders smoothly on orientation change without excessive redraws"
    - "VexFlow notation uses full available horizontal space in landscape"
    - "Orientation changes during gameplay do not lose scroll position or current note state"
  artifacts:
    - path: "src/hooks/useVexFlowResize.js"
      provides: "Debounced ResizeObserver hook for VexFlow"
      exports: ["useVexFlowResize"]
      min_lines: 30
    - path: "src/components/games/sight-reading-game/components/VexFlowStaffDisplay.jsx"
      provides: "VexFlow display with debounced resize"
      contains: "useVexFlowResize"
  key_links:
    - from: "src/hooks/useVexFlowResize.js"
      to: "src/components/games/sight-reading-game/components/VexFlowStaffDisplay.jsx"
      via: "import and usage in resize effect"
      pattern: "useVexFlowResize"
---

<objective>
Create a debounced ResizeObserver hook and integrate it into VexFlowStaffDisplay to handle smooth re-rendering on orientation changes.

Purpose: VexFlowStaffDisplay currently uses a raw ResizeObserver with no debouncing (lines 160-204). During orientation changes, resize events fire rapidly, causing multiple expensive VexFlow re-renders. This plan adds debouncing (150ms) to prevent performance issues while ensuring the notation correctly fills the new container dimensions.

Output: A reusable `useVexFlowResize` hook and a VexFlowStaffDisplay that debounces resize events, preserving scroll position and note state across orientation changes.
</objective>

<execution_context>
@C:/Users/pagis/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/pagis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-game-layout-optimization/03-RESEARCH.md
@src/components/games/sight-reading-game/components/VexFlowStaffDisplay.jsx
@src/hooks/useOrientation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useVexFlowResize debounced hook</name>
  <files>src/hooks/useVexFlowResize.js</files>
  <action>
Create a new file `src/hooks/useVexFlowResize.js` with a debounced ResizeObserver hook. Follow the pattern from the research document (03-RESEARCH.md, Pattern 2):

```javascript
import { useEffect, useRef, useCallback } from 'react';

/**
 * Debounced ResizeObserver hook for VexFlow container re-rendering.
 * Prevents excessive VexFlow redraws during orientation changes.
 *
 * @param {React.RefObject} containerRef - Ref to the observed DOM element
 * @param {Function} onResize - Callback receiving { width: number, height: number }
 * @param {number} [debounceMs=150] - Debounce delay in milliseconds
 */
export function useVexFlowResize(containerRef, onResize, debounceMs = 150) {
  const debounceTimerRef = useRef(null);
  const observerRef = useRef(null);
  const lastSizeRef = useRef({ width: 0, height: 0 });

  const debouncedCallback = useCallback((entries) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    debounceTimerRef.current = setTimeout(() => {
      const entry = entries[0];
      if (!entry) return;
      const { width, height } = entry.contentRect;
      const roundedWidth = Math.round(width);
      const roundedHeight = Math.round(height);

      // Only fire if dimensions actually changed
      if (lastSizeRef.current.width === roundedWidth &&
          lastSizeRef.current.height === roundedHeight) {
        return;
      }

      lastSizeRef.current = { width: roundedWidth, height: roundedHeight };
      onResize({ width: roundedWidth, height: roundedHeight });
    }, debounceMs);
  }, [onResize, debounceMs]);

  useEffect(() => {
    const element = containerRef.current;
    if (!element) return;

    // Fallback for browsers without ResizeObserver
    if (typeof ResizeObserver === 'undefined') {
      const handleResize = () => {
        onResize({
          width: element.clientWidth,
          height: element.clientHeight,
        });
      };
      window.addEventListener('resize', handleResize);
      return () => window.removeEventListener('resize', handleResize);
    }

    observerRef.current = new ResizeObserver(debouncedCallback);
    observerRef.current.observe(element);

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [containerRef, debouncedCallback, onResize]);
}
```

Key design decisions:
- 150ms debounce (research recommendation, balances responsiveness vs performance)
- Deduplication via `lastSizeRef` prevents no-op re-renders
- Cleanup properly clears both timer and observer on unmount
- Falls back to window resize listener for old browsers (same pattern as existing code)
  </action>
  <verify>File exists at `src/hooks/useVexFlowResize.js`. Run `npm run build` to confirm import resolution works (even before integration, the module should parse).</verify>
  <done>useVexFlowResize hook exists with debounced ResizeObserver, dimension deduplication, and cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate debounced resize into VexFlowStaffDisplay</name>
  <files>src/components/games/sight-reading-game/components/VexFlowStaffDisplay.jsx</files>
  <action>
Replace the existing raw ResizeObserver in VexFlowStaffDisplay.jsx (lines 160-204) with the new `useVexFlowResize` hook.

**Step 1:** Add import at top of file:
```javascript
import { useVexFlowResize } from '../../../../hooks/useVexFlowResize';
```

**Step 2:** Create a stable resize callback using useCallback:
```javascript
const handleContainerResize = useCallback(({ width, height }) => {
  setContainerSize((prev) => {
    if (prev.width === width && prev.height === height) return prev;
    return { width, height };
  });
}, []);
```

**Step 3:** Replace the entire `useEffect` block at lines 160-204 (the one that creates ResizeObserver manually) with:
```javascript
useVexFlowResize(containerRef, handleContainerResize, 150);
```

**Step 4:** Remove the now-unused code:
- Delete the entire useEffect that contained `new ResizeObserver(...)` and `window.addEventListener("resize", updateSize)`
- Keep the `containerSize` state and the `responsiveWidth` useMemo that depend on it -- those are unchanged

**What NOT to change:**
- Do NOT modify the `makeSvgResponsive` callback -- it handles viewBox setup and is unrelated to resize detection
- Do NOT modify the scroll preservation logic (maxScrollRef, scrollAnimationRef) -- that remains separate
- Do NOT change the initial `containerSize` state estimate (the useState initializer at line 140-149)
- Do NOT touch the VexFlow rendering logic (renderContent, drawStaff functions)

The existing scroll position preservation in the component (maxScrollRef at line 136, scroll animation at lines 137-139) will continue to work because:
1. containerSize state change triggers re-render
2. VexFlow re-renders with new dimensions
3. Existing scroll restoration logic in the renderContent function preserves position

The debounce ensures this happens once after orientation settles (150ms) instead of 10+ times during the transition.
  </action>
  <verify>
Run `npm run build` to confirm compilation. Run `npm run dev` and test the sight reading game:
1. Start a game session
2. Use browser DevTools to toggle between landscape and portrait viewport
3. Verify notation re-renders correctly to fill the new width
4. Verify no "ResizeObserver loop" console errors
5. Check the browser console for excessive re-render logs (should see only 1 resize callback per orientation change, not 10+)
  </verify>
  <done>VexFlowStaffDisplay uses debounced resize hook. Orientation changes trigger exactly one re-render after 150ms settle time. No scroll position loss. No ResizeObserver loop errors.</done>
</task>

</tasks>

<verification>
- `npm run build` passes
- `src/hooks/useVexFlowResize.js` exports the hook
- VexFlowStaffDisplay imports and uses `useVexFlowResize` instead of raw ResizeObserver
- The old manual ResizeObserver useEffect is removed from VexFlowStaffDisplay
- No game state or rendering logic was modified
</verification>

<success_criteria>
- Debounced resize hook exists and is reusable
- VexFlow notation fills full horizontal space after orientation change
- Orientation changes produce exactly 1 debounced resize callback (not 10+)
- No scroll position or game state loss during orientation change
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-layout-optimization/03-02-SUMMARY.md`
</output>
